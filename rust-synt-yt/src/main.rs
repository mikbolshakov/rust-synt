use std::collections::HashMap; // импорт хэшмэпов из стандартной библиотеки
use std::collections::HashSet;
use std::fs::File; // для работы с файлами
use std::ops::Add; // импорт операции сложения
use std::ops::Sub;

pub fn main() {
    // Владение:
    // 1 - У каждого значения есть владелец
    // 2 - У значения может быть только один владелец в один момент времени
    // 3 - Когда владелец покидает область видимости, значение удаляется и ресурсы памяти освобождаются

    // примитивные типы данных хранятся в стеке, остальные в куче
    // без clone() data перейдет в _anotherdata и к data уже не будет доступа
    // автоматически копируются (без clone() и &) примитивные типы: числа, bool и char (+ кортежи с примит типами)
    let data: String = "some data".to_string();
    let _anotherdata: String = data.clone(); // можно через clone()
    let _anotherdata: &String = &data; // можно через ссылку &

    // array (массивы) (элементы только одного типа)
    let _some_array: [u8; 4] = [1, 3, 5, 7];

    // slice (срезы) (от массивов)
    println!("{:?}", &_some_array[0..2]); // [1, 3]
    println!("{:?}", &_some_array[2..4]); // [5, 7]
    println!("{:?}", &_some_array[..]); // [1, 3, 5, 7]

    // vec (векторы) (динамический массив)
    let mut dinamic_array: Vec<i32> = Vec::new();
    dinamic_array.push(33);
    dinamic_array.push(54);

    // HashMap (структура с ключ:значение, где для ключа используется алгоритм хэширования)
    let mut some_map: HashMap<&str, i32> = HashMap::new();
    some_map.insert("interesting", 27);
    some_map.insert("task", 72);
    println!("{:?}", some_map); // {"interesting": 27, "task": 72}

    // HashSet - хранилище ключей (как хэшмэп, только без значений)
    let mut some_set: HashSet<&str> = HashSet::new();
    some_set.insert("only");
    some_set.insert("keys");
    println!("{:?}", some_set); // {"keys", "only"}

    // tuple (кортежи) (как массив, но могут быть разные элементы в кортеже)
    let _some_data: (f64, &str, bool) = (3.14, "Mike", true);
    let _pi: f64 = _some_data.0;

    // struct (структуры)
    struct User {
        name: String,
        age: usize,
        active: bool,
    }

    let _student: User = User {
        name: "Mike".to_string(),
        age: 26,
        active: true,
    };

    let _student2: User = User {
        age: 25,
        .._student
    };

    // tuple struct
    struct Color(i32, i32, bool);

    let _first_color: Color = Color(31, 53, true);
    let _second_color: i32 = _first_color.1;

    // Методы структур
    // impl - реализация структуры
    // self - ссылка на себя же (аналог this)
    impl User {
        fn _how_old_user(&self) -> usize {
            self.age
        }
        fn _get_older(&mut self) {
            self.age += 1;
        }
    }

    // enum
    enum Calc {
        Add(i32, i32),
        Minus,
        Multiply,
    }
    let _math: Calc = Calc::Add(10, 5);

    // тип Option
    let one: Option<i32> = Some(22);
    match one {
        Some(two) => println!("{}", two),
        None => println!("No result"),
    }
    // тип Result
    // let my_file = File::open("filename.txt");
    // let _my_file = match my_file {
    //     Ok(our_file) => our_file,
    //     Err(error) => panic!("Error: {}", error),
    // };
    // // unwrap - если файл можно открыть без ошибок, то переменная _smf будет содержать результат
    // let _smf = File::open("secfile.txt").unwrap();
    // // expect - то же что и unwrap(), только при ошибке будет panic с сообщением
    // let _smf = File::open("secfile.txt").expect("Не смогли открыть");

    // generics (дженерики) обобщенные типы данных
    pub struct _Shape<T, U> {
        pub x: T,
        pub y: T,
        pub z: U,
    }

    // применяем несколько трейтов к дженерикам через +
    // T: - значит тип Т реализует:
    // Copy - встроенный в язык раст трейт, реализующий заимствование вместо &
    // Add - встроенный трейт - сложение
    // <Output = T> - возвращаем тип Т
    impl<T: Copy + Add<Output = T>, U: Copy> _Shape<T, U> {
        pub fn _get_shape(&self) -> T {
            self.x + self.y
        }
        pub fn _get_z(&self) -> U {
            self.z
        }
    }
    /* аналогичная запись с where
    impl<T, U> _Shape<T, U>
    where
        T: Copy + Add<Output = T>,
        U: Copy,
    {
        pub fn _get_shape(&self) -> T { self.x + self.y }
        pub fn _get_z(&self) -> U { self.z }
    }*/

    pub struct Shape<T> {
        pub x: T,
        pub y: T,
    }

    // применение трейтов в функциях
    fn summ<T: Copy + Add<Output = T>>(figure: Shape<T>) -> T {
        figure.x + figure.y
    }
    // пример вызова
    let fig: Shape<i32> = Shape { x: 10, y: -20 };
    let res: i32 = summ::<i32>(fig); // -10

    // traits (трейты) - аналог интерфейсов
    pub trait ShapeCalculation<T> {
        fn sum(&self) -> T;
    }

    // реализация трейта
    impl<T: Copy + Add<Output = T>> ShapeCalculation<T> for Shape<T> {
        fn sum(&self) -> T {
            self.x + self.y
        }
    }

    // ограничения трейта и взаимодействие с ним (обращение к реализации)
    impl<T: ShapeCalculation<T>> Shape<T>
    where
        T: Copy + Add<Output = T> + Sub<Output = T>,
    {
        pub fn _calcul(&self, z: T) -> T {
            z.sum() - self.x
        }
    }

    // анонимные функции (closures/лямбда функции) (особенность - доступ к переменным окружения)
    let _closure1 = || 10; // функция без аргумента, возвращающая только число 10
    let clo2 = |x: i32| x * 10; // аргумент x, возвращаем х * 10
    let _clo3 = |x: i32| -> f32 { (x * 10) as f32 / 2.0 }; // в {} тело функции

    // функции высшего порядка (аргумент -  другая функция)
    // функциональные типы, описанные через трейты:
    // FnOnce - передача владения (по умолчанию)
    // Fn - заимствование без возможности изменения
    // FnMut - заимствование с возможностью изменения

    // функция как аргумент другой функции:
    fn interest_func<F>(clo2: F) -> i32
    where
        F: FnOnce(i32) -> i32,
    {
        5 * clo2(30)
    }
    println!("Result of function: {:?}", interest_func(clo2)); // 1500

    let x: Vec<i32> = vec![10, 20, 30];
    let z1 = |y: i32| x.iter(); // потом можем обращаться к х
    let z2 = move |y: i32| { x.iter(); }; // потом НЕ можем обращаться к х

    // итераторы(перебирают) и генераторы(производят операции)
    let yld: i32 = vec![1, 2, 3, 4, 5, 6, 7, 8, 9]
        .iter() // проходимся по элементам
        .filter(|x| *x % 2 != 0) // фильтруем элементы, оставляем нечетные
        .map(|i| i * i) // возводим в 2 степень
        .filter(|x| *x < 30) // отбираем результаты меньше 30
        .sum(); // складываем результаты
    println!("Result is {:?}", yld); // Result is 35
}

/*
*   cargo - проектный сборщик раст (аналог npm)
*   use - подключение внешных зависимостей
*   crates.io - сайт содержащий все пакеты для раст
*   макросы - команды с !
*   методы - функции, относящиеся к реализации трейтов в структурах
*   impl - для определения методов, реализации трейтов, структур и тд
*   экземпляр - реализация структуры через переменную (еще реализовать структуру можно через функцию)
*   ассоциированная функция - функция относящаяся ко всей структуре (чаще используют точечные функции для отдельных экземпляров структуры)
*   декомпозиция - использование переменных в структурах для создания новых переменных:
    let dev = ("Mike", 26, "Rust"); - кортеж
    let (name, size, lang) = dev; - декомпозиция
    теперь есть доступ к каждой переменной name, size, lang


*   в расте все реализованно через трейты, нет наследования
*   все итераторы (into_iter, iter, iter_mut) работают через тип Option
элемент => функция next() => элемент => функция next() => закончились элементы => None
*   строки - это вектор байтов Vec<u8>, поэтому строки мы можем разбить на chars по буквам
*   &str является срезом (слайсом) Vec<u8> и если слайсом мы можем получить некоторые элменты массива, тем же слайсом мы можем получить некоторые буквы строки
*   типы Option и Result - enum'ы из стандартной библиотеки раст
*   в расте дженерики не замедляют работу программы
*   чтобы функция возвращала результат не нужно ставить ;
*   ? - аналог Result(Ok, Err) - если ок, то ок, если не ок, то ошибка идет к вызывающему коду
*   перезаписать значение переменной можно двумя способами:
    1) - затенение через let (в новой переменной)
    2) - мутация через mut (в изначальной переменной)



|| - анонимные функции
тип анонимной функции let anon_funct: fn() = ||
переменная area, тип которой анонимная ф-ция, которая в свою очередь принимает структуру Rectangle и возвращает i32
let area: fn(Rectangle) -> i32 = |sizes: Rectangle| -> i32 {
  sizes.weight * sizes.height
}
аналогичный пример let sum: fn(i32, i32) -> i32 = |a, b| a + b;

let array = [1, 2, 3, 4]
let vector = vec![1, 2, 3, 4]
let vector2: Vec<i32> = Vec::new()



::
1) объявление строки String::from("Rust")
2) вызов pub функции из модуля module::function()
3) обращение к структуре и ее полю Struct::Field(params) может быть и без (params)
4) обращение к enum и его полю (то же касается Option и Result) Option::Some()
5) работа со стандартными библиотеками File::open()
6) создание нового вектора или HashMapа let v1 = Vec::new()
7) ассоциированные типы для лучшей читаемости кода
trait Contains {
  type A;
  type B;
  fn contains(&self, &Self::A, &Self::B) -> bool;
}



атрибут - метаданные применяемые к модулю, контейнеру или элементу
Перечень того, что можно делать с помощью атрибутов:
- задать условия компиляции кода;
- задать имя, версию и тип контейнера;
- отключить проверки;
- включить возможности компилятора (макросы, глобальный импорт ...);
- линковаться с внешней библиотекой;
- пометить функции, как модульные тесты;
- пометить функции, которые будут частью теста производительности.

#[derive(Clone, Copy)] //трейт Copy нельзя использовать без трейта Clone
стандартные трейты можно написать самостоятельно, это не сложно, но легче импортировать через атрибут derive
трейты как интерфейсы: с пустой функцией (или с полной, если это по дефолту), а ниже через impl реализация функции
*   Clone        для создания Т из &Т с помощью копии без clone() и & (даже тех что в куче)
*   Copy         для создания типа семантикой копирования, вместо перемещения
*   Hash         для вычисления хэша из &T
*   Iterator     для итреирования по коллекциям
*   Drop         освобождает ресурс которыми владеет экземпляр реализации
*   Debug        для вывода переменных в println! через форматированный вывод с помощью {:?}
*   Default      чтобы создать пустой экземпляр типа данных
*   PartialOrd   для больше >, меньше <
*   PartialEq    для сравнения переменных разных типов
fn is_eq<T: PartialEq>(item1: T, item2: T) -> bool {
  item1 == item2
}
*   Deref        возвращает ссылку, * - оператор разыменования
let x = 5
let y = &x
assert_eq!(5, x);
assert_eq!(5, *y); - ссылаемся на x


packeges - функционал cargo, позволяющий собирать, тестировать и делиться крейтами: cargo new "название"
Состоит из одного или нескольких крейтов, которые представляют из себя набор функций
packege:
1) может содержать не более 1 библиотечного крейта (library crate)
2) любое число исполняемых крейтов (binary crates)
3) должен содержать хотя бы один крейт (lib or bin)
crates - дерево модулей, которое содержит библиотечный или исполняемый файл
Это исполняемый файл или библиотека (ее нельзя исполнить, но можно подключить) например два крейта: main.rs с ф-цией main и lib.rs, в котором размещают библиотеки
modules - позволяют вместе контролировать организацию, область видимости и конфиденциальность путей
Модули кода. Чтобы вызвать модуль в другой части проекта нужно модуль сделать pub публичным и его методы тоже
paths - способ именования элемента такого как структура, функция или модуль
Два типа: абсолютный absolute path (crate) и относительный relative path (self)
Раст позволяет разбить пакет на несколько крейтов, а крейты разбить на модули (в модулях код приватный, но можно сделать pub)
можно ссылаться на модули или их элементы из других модулей используя абсолютные или относительные пути



lifetime - время жизни переменной - на протяжении скольких строк кода она доступна - избегание использования несуществующих данных 
'a - явное время жизни (произвольное любое название)
можно явно не указывать

Box - ссылка на часть памяти в куче
переменные типа Box хранят данные в куче и помогают в работе с типами данных которые ссылаются сами на себя
1) когда есть тип, размер которого не извеcтен во время компиляции
2) если есть объем данных, который мы передаем во владение и хотим быть уверены что данные будут скопированы
3) когда хотим иметь значение и важно что тип реализует типаж и не является конкретным типом

код в мейн - главный поток
канал channel из стандартной библиотеки раст нужны для взаимодействия потоков
фьючерсов(тасок) может выполняться асинхронно (иногда сравнивают с потоками)

умный указатель Rc из стандартной библиотеки - нужен для множественного владения когда во время компиляции мы не знаем сколько частей кода будет использовать наш объект

use core::cell::RefCell
RefCell - позволяет изменять данные даже если ссылки на эти данные неизменяемые
 
в расте возможна утечка памяти (memory leak)
через *, Rc, RefCell 
есть еще слабые ссылки Weak links чтобы убирать циклические зависимости
 
код в мейн - главный поток
канал channel из стандартной библиотеки раст нужны для взаимодействия потоков
фьючерсов(тасок) может выполняться асинхронно (иногда сравнивают с потоками)

Mutex - взаимное исключение - позволяет одному потоку получить доступ к любым данным в любой момент времени
lock - отслеживает кто в настоящее время имеет доступ к данным
это нужно для разделения кода на потоки, которые работают отдельно друг от друга
Но есть риск взаимных блокировок, типо затенения каналов
*/